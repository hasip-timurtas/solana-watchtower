//! Alert management system for Solana monitoring.

use crate::rules::AlertSeverity;
use chrono::{DateTime, Utc};
use dashmap::DashMap;
use serde::{Deserialize, Serialize};
use solana_sdk::pubkey::Pubkey;
use std::collections::HashMap;
use std::sync::Arc;
use thiserror::Error;
use tokio::sync::{broadcast, RwLock};
use tracing::{debug, error, info, warn};
use uuid::Uuid;

/// An alert generated by a monitoring rule.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Alert {
    /// Unique alert identifier
    pub id: String,

    /// Name of the rule that generated this alert
    pub rule_name: String,

    /// Alert message
    pub message: String,

    /// Alert severity level
    pub severity: AlertSeverity,

    /// Program that triggered the alert
    pub program_id: Pubkey,

    /// Human-readable program name
    pub program_name: String,

    /// Associated event ID (if applicable)
    pub event_id: Option<String>,

    /// Additional metadata
    pub metadata: HashMap<String, serde_json::Value>,

    /// Confidence score (0.0 to 1.0)
    pub confidence: f64,

    /// Suggested actions for resolving the alert
    pub suggested_actions: Vec<String>,

    /// Timestamp when the alert was generated
    pub timestamp: DateTime<Utc>,

    /// Whether the alert has been acknowledged
    pub acknowledged: bool,

    /// Whether the alert has been resolved
    pub resolved: bool,
}

/// Alert manager that handles alert storage, filtering, and notifications.
pub struct AlertManager {
    /// Active alerts storage
    alerts: Arc<DashMap<String, Alert>>,

    /// Alert history (limited size)
    history: Arc<RwLock<Vec<Alert>>>,

    /// Alert broadcasters
    alert_sender: broadcast::Sender<Alert>,

    /// Configuration
    config: AlertManagerConfig,

    /// Alert statistics
    stats: Arc<RwLock<AlertStatistics>>,
}

/// Configuration for alert manager.
#[derive(Debug, Clone)]
pub struct AlertManagerConfig {
    /// Maximum number of active alerts to keep
    pub max_active_alerts: usize,

    /// Maximum number of alerts in history
    pub max_history_size: usize,

    /// Auto-resolve alerts older than this duration (in seconds)
    pub auto_resolve_age_seconds: u64,

    /// Whether to deduplicate similar alerts
    pub enable_deduplication: bool,

    /// Deduplication window (in seconds)
    pub deduplication_window_seconds: u64,
}

/// Alert filtering criteria.
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct AlertFilter {
    /// Filter by severity levels
    pub severities: Option<Vec<AlertSeverity>>,

    /// Filter by rule names
    pub rule_names: Option<Vec<String>>,

    /// Filter by program IDs
    pub program_ids: Option<Vec<Pubkey>>,

    /// Filter by acknowledged status
    pub acknowledged: Option<bool>,

    /// Filter by resolved status
    pub resolved: Option<bool>,

    /// Filter by time range
    pub time_range: Option<TimeRange>,

    /// Filter by confidence threshold
    pub min_confidence: Option<f64>,
}

/// Time range for filtering alerts.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TimeRange {
    /// Start time (inclusive)
    pub start: DateTime<Utc>,

    /// End time (exclusive)
    pub end: DateTime<Utc>,
}

/// Alert statistics for monitoring.
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct AlertStatistics {
    /// Total alerts generated
    pub total_alerts: u64,

    /// Alerts by severity
    pub by_severity: HashMap<String, u64>,

    /// Alerts by rule
    pub by_rule: HashMap<String, u64>,

    /// Alerts by program
    pub by_program: HashMap<String, u64>,

    /// Acknowledged alerts
    pub acknowledged_count: u64,

    /// Resolved alerts
    pub resolved_count: u64,

    /// Average resolution time (in seconds)
    pub avg_resolution_time_seconds: Option<f64>,
}

/// Errors that can occur in alert management.
#[derive(Error, Debug)]
pub enum AlertError {
    #[error("Alert not found: {id}")]
    NotFound { id: String },

    #[error("Invalid alert data: {0}")]
    InvalidData(String),

    #[error("Serialization error: {0}")]
    Serialization(#[from] serde_json::Error),

    #[error("Alert operation failed: {0}")]
    Operation(String),
}

pub type AlertResult<T> = Result<T, AlertError>;

impl Default for AlertManager {
    fn default() -> Self {
        Self::new()
    }
}

impl AlertManager {
    /// Create a new alert manager.
    pub fn new() -> Self {
        Self::with_config(AlertManagerConfig::default())
    }

    /// Create a new alert manager with custom configuration.
    pub fn with_config(config: AlertManagerConfig) -> Self {
        let (alert_sender, _) = broadcast::channel(1000);

        Self {
            alerts: Arc::new(DashMap::new()),
            history: Arc::new(RwLock::new(Vec::new())),
            alert_sender,
            config,
            stats: Arc::new(RwLock::new(AlertStatistics::default())),
        }
    }

    /// Send an alert through the system.
    pub async fn send_alert(&self, mut alert: Alert) -> AlertResult<()> {
        // Check for deduplication
        if self.config.enable_deduplication {
            if let Some(existing_alert) = self.find_duplicate(&alert).await {
                debug!("Deduplicated alert for rule {}", alert.rule_name);
                // Update the existing alert's timestamp
                self.update_alert_timestamp(&existing_alert.id).await?;
                return Ok(());
            }
        }

        // Ensure unique ID
        if alert.id.is_empty() {
            alert.id = Uuid::new_v4().to_string();
        }

        // Add to active alerts
        self.alerts.insert(alert.id.clone(), alert.clone());

        // Update statistics
        self.update_statistics(&alert).await;

        // Broadcast alert
        if let Err(e) = self.alert_sender.send(alert.clone()) {
            warn!("Failed to broadcast alert {}: {}", alert.id, e);
        }

        // Cleanup old alerts
        self.cleanup_alerts().await;

        info!(
            "Alert generated: {} - {} ({})",
            alert.id,
            alert.message,
            alert.severity.as_str()
        );

        Ok(())
    }

    /// Get an alert by ID.
    pub fn get_alert(&self, alert_id: &str) -> Option<Alert> {
        self.alerts.get(alert_id).map(|entry| entry.clone())
    }

    /// List alerts with optional filtering.
    pub async fn list_alerts(&self, filter: Option<AlertFilter>) -> Vec<Alert> {
        let alerts: Vec<Alert> = self.alerts.iter().map(|entry| entry.clone()).collect();

        if let Some(filter) = filter {
            self.apply_filter(alerts, &filter)
        } else {
            alerts
        }
    }

    /// Acknowledge an alert.
    pub async fn acknowledge_alert(&self, alert_id: &str) -> AlertResult<()> {
        if let Some(mut alert_entry) = self.alerts.get_mut(alert_id) {
            alert_entry.acknowledged = true;

            // Update statistics
            let mut stats = self.stats.write().await;
            stats.acknowledged_count += 1;

            info!("Alert acknowledged: {}", alert_id);
            Ok(())
        } else {
            Err(AlertError::NotFound {
                id: alert_id.to_string(),
            })
        }
    }

    /// Resolve an alert.
    pub async fn resolve_alert(&self, alert_id: &str) -> AlertResult<()> {
        if let Some(alert) = self.alerts.remove(alert_id) {
            let mut resolved_alert = alert.1;
            resolved_alert.resolved = true;

            // Add to history
            let mut history = self.history.write().await;
            history.push(resolved_alert.clone());

            // Limit history size
            if history.len() > self.config.max_history_size {
                history.remove(0);
            }

            // Update statistics
            let mut stats = self.stats.write().await;
            stats.resolved_count += 1;

            // Calculate resolution time
            let resolution_time = (Utc::now() - resolved_alert.timestamp).num_seconds() as f64;
            if let Some(avg_time) = stats.avg_resolution_time_seconds {
                stats.avg_resolution_time_seconds = Some((avg_time + resolution_time) / 2.0);
            } else {
                stats.avg_resolution_time_seconds = Some(resolution_time);
            }

            info!("Alert resolved: {}", alert_id);
            Ok(())
        } else {
            Err(AlertError::NotFound {
                id: alert_id.to_string(),
            })
        }
    }

    /// Subscribe to alerts.
    pub fn subscribe(&self) -> broadcast::Receiver<Alert> {
        self.alert_sender.subscribe()
    }

    /// Get alert statistics.
    pub async fn statistics(&self) -> AlertStatistics {
        self.stats.read().await.clone()
    }

    /// Get alert history.
    pub async fn history(&self, filter: Option<AlertFilter>) -> Vec<Alert> {
        let history = self.history.read().await.clone();

        if let Some(filter) = filter {
            self.apply_filter(history, &filter)
        } else {
            history
        }
    }

    /// Clear all alerts and history.
    pub async fn clear_all(&self) {
        self.alerts.clear();
        self.history.write().await.clear();

        // Reset statistics
        let mut stats = self.stats.write().await;
        *stats = AlertStatistics::default();

        info!("Cleared all alerts and history");
    }

    /// Find duplicate alert within deduplication window.
    async fn find_duplicate(&self, alert: &Alert) -> Option<Alert> {
        let window_start =
            Utc::now() - chrono::Duration::seconds(self.config.deduplication_window_seconds as i64);

        for entry in self.alerts.iter() {
            let existing = entry.value();
            if existing.rule_name == alert.rule_name
                && existing.program_id == alert.program_id
                && existing.timestamp >= window_start
                && !existing.resolved
            {
                return Some(existing.clone());
            }
        }

        None
    }

    /// Update the timestamp of an existing alert.
    async fn update_alert_timestamp(&self, alert_id: &str) -> AlertResult<()> {
        if let Some(mut alert_entry) = self.alerts.get_mut(alert_id) {
            alert_entry.timestamp = Utc::now();
            Ok(())
        } else {
            Err(AlertError::NotFound {
                id: alert_id.to_string(),
            })
        }
    }

    /// Update alert statistics.
    async fn update_statistics(&self, alert: &Alert) {
        let mut stats = self.stats.write().await;

        stats.total_alerts += 1;

        // Update by severity
        let severity_key = alert.severity.as_str().to_string();
        *stats.by_severity.entry(severity_key).or_insert(0) += 1;

        // Update by rule
        *stats.by_rule.entry(alert.rule_name.clone()).or_insert(0) += 1;

        // Update by program
        *stats
            .by_program
            .entry(alert.program_name.clone())
            .or_insert(0) += 1;
    }

    /// Apply filtering to a list of alerts.
    fn apply_filter(&self, alerts: Vec<Alert>, filter: &AlertFilter) -> Vec<Alert> {
        alerts
            .into_iter()
            .filter(|alert| {
                // Filter by severity
                if let Some(severities) = &filter.severities {
                    if !severities.contains(&alert.severity) {
                        return false;
                    }
                }

                // Filter by rule names
                if let Some(rule_names) = &filter.rule_names {
                    if !rule_names.contains(&alert.rule_name) {
                        return false;
                    }
                }

                // Filter by program IDs
                if let Some(program_ids) = &filter.program_ids {
                    if !program_ids.contains(&alert.program_id) {
                        return false;
                    }
                }

                // Filter by acknowledged status
                if let Some(acknowledged) = filter.acknowledged {
                    if alert.acknowledged != acknowledged {
                        return false;
                    }
                }

                // Filter by resolved status
                if let Some(resolved) = filter.resolved {
                    if alert.resolved != resolved {
                        return false;
                    }
                }

                // Filter by time range
                if let Some(time_range) = &filter.time_range {
                    if alert.timestamp < time_range.start || alert.timestamp >= time_range.end {
                        return false;
                    }
                }

                // Filter by confidence threshold
                if let Some(min_confidence) = filter.min_confidence {
                    if alert.confidence < min_confidence {
                        return false;
                    }
                }

                true
            })
            .collect()
    }

    /// Clean up old alerts and manage capacity.
    async fn cleanup_alerts(&self) {
        // Auto-resolve old alerts
        let cutoff_time =
            Utc::now() - chrono::Duration::seconds(self.config.auto_resolve_age_seconds as i64);
        let mut alerts_to_resolve = Vec::new();

        for entry in self.alerts.iter() {
            if entry.timestamp < cutoff_time && !entry.resolved {
                alerts_to_resolve.push(entry.id.clone());
            }
        }

        for alert_id in alerts_to_resolve {
            if let Err(e) = self.resolve_alert(&alert_id).await {
                error!("Failed to auto-resolve alert {}: {}", alert_id, e);
            }
        }

        // Limit active alerts
        if self.alerts.len() > self.config.max_active_alerts {
            // Remove oldest alerts (simple FIFO strategy)
            let mut oldest_alerts: Vec<_> = self
                .alerts
                .iter()
                .map(|entry| (entry.timestamp, entry.id.clone()))
                .collect();

            oldest_alerts.sort_by(|a, b| a.0.cmp(&b.0));

            let excess = self.alerts.len() - self.config.max_active_alerts;
            for (_, alert_id) in oldest_alerts.into_iter().take(excess) {
                if let Err(e) = self.resolve_alert(&alert_id).await {
                    error!("Failed to remove old alert {}: {}", alert_id, e);
                }
            }
        }
    }
}

impl Default for AlertManagerConfig {
    fn default() -> Self {
        Self {
            max_active_alerts: 1000,
            max_history_size: 10000,
            auto_resolve_age_seconds: 86400, // 24 hours
            enable_deduplication: true,
            deduplication_window_seconds: 300, // 5 minutes
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::rules::AlertSeverity;
    use solana_sdk::pubkey::Pubkey;

    #[tokio::test]
    async fn test_alert_manager_creation() {
        let manager = AlertManager::new();
        let stats = manager.statistics().await;
        assert_eq!(stats.total_alerts, 0);
    }

    #[tokio::test]
    async fn test_send_and_retrieve_alert() {
        let manager = AlertManager::new();

        let alert = Alert {
            id: "test-alert".to_string(),
            rule_name: "test_rule".to_string(),
            message: "Test alert message".to_string(),
            severity: AlertSeverity::Medium,
            program_id: Pubkey::new_unique(),
            program_name: "Test Program".to_string(),
            event_id: None,
            metadata: HashMap::new(),
            confidence: 0.8,
            suggested_actions: vec!["Test action".to_string()],
            timestamp: Utc::now(),
            acknowledged: false,
            resolved: false,
        };

        manager.send_alert(alert.clone()).await.unwrap();

        let retrieved = manager.get_alert("test-alert").unwrap();
        assert_eq!(retrieved.rule_name, "test_rule");
        assert_eq!(retrieved.message, "Test alert message");

        let stats = manager.statistics().await;
        assert_eq!(stats.total_alerts, 1);
    }

    #[tokio::test]
    async fn test_alert_acknowledgment() {
        let manager = AlertManager::new();

        let alert = Alert {
            id: "test-alert".to_string(),
            rule_name: "test_rule".to_string(),
            message: "Test alert message".to_string(),
            severity: AlertSeverity::High,
            program_id: Pubkey::new_unique(),
            program_name: "Test Program".to_string(),
            event_id: None,
            metadata: HashMap::new(),
            confidence: 0.9,
            suggested_actions: Vec::new(),
            timestamp: Utc::now(),
            acknowledged: false,
            resolved: false,
        };

        manager.send_alert(alert).await.unwrap();
        manager.acknowledge_alert("test-alert").await.unwrap();

        let retrieved = manager.get_alert("test-alert").unwrap();
        assert!(retrieved.acknowledged);

        let stats = manager.statistics().await;
        assert_eq!(stats.acknowledged_count, 1);
    }

    #[tokio::test]
    async fn test_alert_resolution() {
        let manager = AlertManager::new();

        let alert = Alert {
            id: "test-alert".to_string(),
            rule_name: "test_rule".to_string(),
            message: "Test alert message".to_string(),
            severity: AlertSeverity::Critical,
            program_id: Pubkey::new_unique(),
            program_name: "Test Program".to_string(),
            event_id: None,
            metadata: HashMap::new(),
            confidence: 1.0,
            suggested_actions: Vec::new(),
            timestamp: Utc::now(),
            acknowledged: false,
            resolved: false,
        };

        manager.send_alert(alert).await.unwrap();
        manager.resolve_alert("test-alert").await.unwrap();

        // Alert should no longer be active
        assert!(manager.get_alert("test-alert").is_none());

        // But should be in history
        let history = manager.history(None).await;
        assert_eq!(history.len(), 1);
        assert!(history[0].resolved);

        let stats = manager.statistics().await;
        assert_eq!(stats.resolved_count, 1);
    }
}
