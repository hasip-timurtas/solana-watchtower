//! Rule system for monitoring Solana program events and detecting anomalies.

use async_trait::async_trait;
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use thiserror::Error;

/// Trait for implementing monitoring rules.
#[async_trait]
pub trait Rule: Send + Sync {
    /// Unique name for this rule.
    fn name(&self) -> &str;

    /// Human-readable description of what this rule detects.
    fn description(&self) -> &str;

    /// Severity level for alerts generated by this rule.
    fn severity(&self) -> AlertSeverity;

    /// Evaluate a program event against this rule.
    async fn evaluate(&self, event: &ProgramEvent, context: &RuleContext) -> RuleResult;

    /// Whether this rule is enabled.
    fn is_enabled(&self) -> bool {
        true
    }

    /// Rule-specific configuration.
    fn config(&self) -> &dyn std::any::Any {
        &()
    }
}

/// Context provided to rules during evaluation.
#[derive(Debug, Clone)]
pub struct RuleContext {
    /// Historical events for analysis
    pub recent_events: Vec<ProgramEvent>,

    /// Current metrics snapshot
    pub metrics: HashMap<String, f64>,

    /// Rule configuration
    pub config: HashMap<String, serde_json::Value>,

    /// Timestamp of evaluation
    pub timestamp: DateTime<Utc>,
}

/// Result of rule evaluation.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RuleResult {
    /// Rule that was evaluated
    pub rule_name: String,

    /// Whether the rule triggered an alert
    pub triggered: bool,

    /// Alert message if triggered
    pub message: Option<String>,

    /// Severity level
    pub severity: AlertSeverity,

    /// Additional metadata
    pub metadata: HashMap<String, serde_json::Value>,

    /// Confidence score (0.0 to 1.0)
    pub confidence: f64,

    /// Suggested actions
    pub suggested_actions: Vec<String>,

    /// Evaluation timestamp
    pub timestamp: DateTime<Utc>,
}

/// Alert severity levels.
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq, PartialOrd, Ord)]
pub enum AlertSeverity {
    /// Informational alerts
    Info,
    /// Low priority alerts
    Low,
    /// Medium priority alerts
    Medium,
    /// High priority alerts
    High,
    /// Critical alerts requiring immediate attention
    Critical,
}

/// Error types for rule evaluation.
#[derive(Error, Debug)]
pub enum RuleError {
    #[error("Rule configuration error: {0}")]
    Configuration(String),

    #[error("Rule evaluation error: {0}")]
    Evaluation(String),

    #[error("Missing required data: {0}")]
    MissingData(String),

    #[error("Invalid metric value: {0}")]
    InvalidMetric(String),
}

/// Re-export event types from subscriber
pub use watchtower_subscriber::{EventData, EventType, ProgramEvent};

// Built-in rules

/// Rule that detects sudden liquidity drops.
#[derive(Debug, Clone)]
pub struct LiquidityDropRule {
    /// Threshold percentage for triggering alert
    pub threshold_pct: f64,
    /// Time window in seconds
    pub window_seconds: u64,
    /// Minimum liquidity amount to consider
    pub min_liquidity: u64,
}

impl LiquidityDropRule {
    pub fn new(threshold_pct: f64, window_seconds: u64, min_liquidity: u64) -> Self {
        Self {
            threshold_pct,
            window_seconds,
            min_liquidity,
        }
    }
}

#[async_trait]
impl Rule for LiquidityDropRule {
    fn name(&self) -> &str {
        "liquidity_drop"
    }

    fn description(&self) -> &str {
        "Detects sudden drops in program liquidity"
    }

    fn severity(&self) -> AlertSeverity {
        AlertSeverity::High
    }

    async fn evaluate(&self, event: &ProgramEvent, context: &RuleContext) -> RuleResult {
        let mut result = RuleResult {
            rule_name: self.name().to_string(),
            triggered: false,
            message: None,
            severity: self.severity(),
            metadata: HashMap::new(),
            confidence: 0.0,
            suggested_actions: Vec::new(),
            timestamp: Utc::now(),
        };

        // Check if this is a token transfer or account change
        if let EventData::TokenTransfer { amount, .. } = &event.data {
            // Get recent similar events within the time window
            let window_start =
                event.timestamp - chrono::Duration::seconds(self.window_seconds as i64);
            let recent_transfers: Vec<_> = context
                .recent_events
                .iter()
                .filter(|e| e.timestamp >= window_start)
                .filter(|e| matches!(e.data, EventData::TokenTransfer { .. }))
                .collect();

            if !recent_transfers.is_empty() {
                let total_amount_out: u64 = recent_transfers
                    .iter()
                    .filter_map(|e| {
                        if let EventData::TokenTransfer { amount, .. } = &e.data {
                            Some(*amount)
                        } else {
                            None
                        }
                    })
                    .sum();

                // Calculate liquidity drop percentage
                if total_amount_out >= self.min_liquidity {
                    let drop_pct = (*amount as f64 / total_amount_out as f64) * 100.0;

                    if drop_pct >= self.threshold_pct {
                        result.triggered = true;
                        result.message = Some(format!(
                            "Liquidity drop of {:.2}% detected in {} seconds (threshold: {:.2}%)",
                            drop_pct, self.window_seconds, self.threshold_pct
                        ));
                        result.confidence = (drop_pct / 100.0).min(1.0);
                        result
                            .metadata
                            .insert("drop_percentage".to_string(), drop_pct.into());
                        result
                            .metadata
                            .insert("amount".to_string(), (*amount).into());
                        result
                            .suggested_actions
                            .push("Monitor for market manipulation".to_string());
                        result
                            .suggested_actions
                            .push("Check for flash loan attacks".to_string());
                    }
                }
            }
        }

        result
    }
}

/// Rule that detects unusually large single transactions.
#[derive(Debug, Clone)]
pub struct LargeTransactionRule {
    /// Threshold as percentage of TVL
    pub tvl_threshold_pct: f64,
    /// Absolute amount threshold
    pub amount_threshold: u64,
}

impl LargeTransactionRule {
    pub fn new(tvl_threshold_pct: f64, amount_threshold: u64) -> Self {
        Self {
            tvl_threshold_pct,
            amount_threshold,
        }
    }
}

#[async_trait]
impl Rule for LargeTransactionRule {
    fn name(&self) -> &str {
        "large_transaction"
    }

    fn description(&self) -> &str {
        "Detects unusually large single transactions"
    }

    fn severity(&self) -> AlertSeverity {
        AlertSeverity::Medium
    }

    async fn evaluate(&self, event: &ProgramEvent, context: &RuleContext) -> RuleResult {
        let mut result = RuleResult {
            rule_name: self.name().to_string(),
            triggered: false,
            message: None,
            severity: self.severity(),
            metadata: HashMap::new(),
            confidence: 0.0,
            suggested_actions: Vec::new(),
            timestamp: Utc::now(),
        };

        if let EventData::TokenTransfer { amount, .. } = &event.data {
            // Check absolute threshold
            if *amount >= self.amount_threshold {
                result.triggered = true;
                result.message = Some(format!(
                    "Large transaction detected: {} (threshold: {})",
                    amount, self.amount_threshold
                ));
                result.confidence = 0.8;
                result
                    .metadata
                    .insert("amount".to_string(), (*amount).into());
                result
                    .suggested_actions
                    .push("Verify transaction legitimacy".to_string());
            }

            // Check TVL percentage if available
            if let Some(tvl) = context.metrics.get("total_value_locked") {
                let pct_of_tvl = (*amount as f64 / tvl) * 100.0;
                if pct_of_tvl >= self.tvl_threshold_pct {
                    result.triggered = true;
                    result.message = Some(format!(
                        "Transaction represents {:.2}% of TVL (threshold: {:.2}%)",
                        pct_of_tvl, self.tvl_threshold_pct
                    ));
                    result.confidence = (pct_of_tvl / 100.0).min(1.0);
                    result
                        .metadata
                        .insert("tvl_percentage".to_string(), pct_of_tvl.into());
                    result
                        .suggested_actions
                        .push("Monitor for large player activity".to_string());
                }
            }
        }

        result
    }
}

/// Rule that detects potential oracle manipulation.
#[derive(Debug, Clone)]
pub struct OracleDeviationRule {
    /// Maximum allowed price deviation percentage
    pub max_deviation_pct: f64,
    /// Reference oracle key
    pub reference_oracle: String,
}

impl OracleDeviationRule {
    pub fn new(max_deviation_pct: f64, reference_oracle: String) -> Self {
        Self {
            max_deviation_pct,
            reference_oracle,
        }
    }
}

#[async_trait]
impl Rule for OracleDeviationRule {
    fn name(&self) -> &str {
        "oracle_deviation"
    }

    fn description(&self) -> &str {
        "Detects potential oracle price manipulation"
    }

    fn severity(&self) -> AlertSeverity {
        AlertSeverity::Critical
    }

    async fn evaluate(&self, event: &ProgramEvent, context: &RuleContext) -> RuleResult {
        let mut result = RuleResult {
            rule_name: self.name().to_string(),
            triggered: false,
            message: None,
            severity: self.severity(),
            metadata: HashMap::new(),
            confidence: 0.0,
            suggested_actions: Vec::new(),
            timestamp: Utc::now(),
        };

        // Check for oracle price updates in the event
        if let Some(serde_json::Value::Number(price)) = event.metadata.get("oracle_price") {
            if let Some(reference_price) = context.metrics.get(&self.reference_oracle) {
                let price_val = price.as_f64().unwrap_or(0.0);
                let deviation_pct = ((price_val - reference_price).abs() / reference_price) * 100.0;

                if deviation_pct >= self.max_deviation_pct {
                    result.triggered = true;
                    result.message = Some(format!(
                        "Oracle price deviation of {:.2}% detected (threshold: {:.2}%)",
                        deviation_pct, self.max_deviation_pct
                    ));
                    result.confidence = (deviation_pct / 100.0).min(1.0);
                    result
                        .metadata
                        .insert("deviation_percentage".to_string(), deviation_pct.into());
                    result
                        .metadata
                        .insert("current_price".to_string(), price_val.into());
                    result
                        .metadata
                        .insert("reference_price".to_string(), (*reference_price).into());
                    result
                        .suggested_actions
                        .push("Halt trading immediately".to_string());
                    result
                        .suggested_actions
                        .push("Investigate oracle data source".to_string());
                    result
                        .suggested_actions
                        .push("Contact oracle provider".to_string());
                }
            }
        }

        result
    }
}

/// Rule that detects high transaction failure rates.
#[derive(Debug, Clone)]
pub struct FailureRateRule {
    /// Maximum allowed failure rate percentage
    pub max_failure_rate_pct: f64,
    /// Minimum number of transactions to evaluate
    pub min_transaction_count: usize,
    /// Time window in seconds
    pub window_seconds: u64,
}

impl FailureRateRule {
    pub fn new(
        max_failure_rate_pct: f64,
        min_transaction_count: usize,
        window_seconds: u64,
    ) -> Self {
        Self {
            max_failure_rate_pct,
            min_transaction_count,
            window_seconds,
        }
    }
}

#[async_trait]
impl Rule for FailureRateRule {
    fn name(&self) -> &str {
        "high_failure_rate"
    }

    fn description(&self) -> &str {
        "Detects high transaction failure rates"
    }

    fn severity(&self) -> AlertSeverity {
        AlertSeverity::Medium
    }

    async fn evaluate(&self, event: &ProgramEvent, context: &RuleContext) -> RuleResult {
        let mut result = RuleResult {
            rule_name: self.name().to_string(),
            triggered: false,
            message: None,
            severity: self.severity(),
            metadata: HashMap::new(),
            confidence: 0.0,
            suggested_actions: Vec::new(),
            timestamp: Utc::now(),
        };

        // Only evaluate on transaction events
        if event.is_transaction() {
            let window_start =
                event.timestamp - chrono::Duration::seconds(self.window_seconds as i64);
            let recent_transactions: Vec<_> = context
                .recent_events
                .iter()
                .filter(|e| e.timestamp >= window_start && e.is_transaction())
                .collect();

            if recent_transactions.len() >= self.min_transaction_count {
                let failed_count = recent_transactions
                    .iter()
                    .filter(|e| e.is_successful() == Some(false))
                    .count();

                let failure_rate = (failed_count as f64 / recent_transactions.len() as f64) * 100.0;

                if failure_rate >= self.max_failure_rate_pct {
                    result.triggered = true;
                    result.message = Some(format!(
                        "High failure rate detected: {:.2}% ({}/{} transactions)",
                        failure_rate,
                        failed_count,
                        recent_transactions.len()
                    ));
                    result.confidence = (failure_rate / 100.0).min(1.0);
                    result
                        .metadata
                        .insert("failure_rate".to_string(), failure_rate.into());
                    result
                        .metadata
                        .insert("failed_count".to_string(), failed_count.into());
                    result
                        .metadata
                        .insert("total_count".to_string(), recent_transactions.len().into());
                    result
                        .suggested_actions
                        .push("Check program logic for errors".to_string());
                    result
                        .suggested_actions
                        .push("Monitor network congestion".to_string());
                }
            }
        }

        result
    }
}

impl AlertSeverity {
    /// Get the string representation of the severity level.
    pub fn as_str(&self) -> &str {
        match self {
            AlertSeverity::Info => "info",
            AlertSeverity::Low => "low",
            AlertSeverity::Medium => "medium",
            AlertSeverity::High => "high",
            AlertSeverity::Critical => "critical",
        }
    }

    /// Get a color code for display purposes.
    pub fn color(&self) -> &str {
        match self {
            AlertSeverity::Info => "#007bff",     // Blue
            AlertSeverity::Low => "#28a745",      // Green
            AlertSeverity::Medium => "#ffc107",   // Yellow
            AlertSeverity::High => "#fd7e14",     // Orange
            AlertSeverity::Critical => "#dc3545", // Red
        }
    }

    /// Get priority score for sorting.
    pub fn priority(&self) -> u8 {
        match self {
            AlertSeverity::Info => 1,
            AlertSeverity::Low => 2,
            AlertSeverity::Medium => 3,
            AlertSeverity::High => 4,
            AlertSeverity::Critical => 5,
        }
    }
}

impl Default for RuleContext {
    fn default() -> Self {
        Self {
            recent_events: Vec::new(),
            metrics: HashMap::new(),
            config: HashMap::new(),
            timestamp: Utc::now(),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use solana_sdk::pubkey::Pubkey;
    use watchtower_subscriber::{EventData, EventType, ProgramEvent};

    #[tokio::test]
    async fn test_liquidity_drop_rule() {
        let rule = LiquidityDropRule::new(10.0, 60, 1000);

        let event = ProgramEvent::new(
            Pubkey::new_unique(),
            "Test Program".to_string(),
            EventType::TokenTransfer,
            EventData::TokenTransfer {
                from: Pubkey::new_unique(),
                to: Pubkey::new_unique(),
                amount: 500,
                mint: Pubkey::new_unique(),
                decimals: 6,
            },
        );

        let context = RuleContext::default();
        let result = rule.evaluate(&event, &context).await;

        assert_eq!(result.rule_name, "liquidity_drop");
        // Should not trigger without sufficient historical data
        assert!(!result.triggered);
    }

    #[tokio::test]
    async fn test_large_transaction_rule() {
        let rule = LargeTransactionRule::new(1.0, 1000000);

        let event = ProgramEvent::new(
            Pubkey::new_unique(),
            "Test Program".to_string(),
            EventType::TokenTransfer,
            EventData::TokenTransfer {
                from: Pubkey::new_unique(),
                to: Pubkey::new_unique(),
                amount: 2000000, // Above threshold
                mint: Pubkey::new_unique(),
                decimals: 6,
            },
        );

        let context = RuleContext::default();
        let result = rule.evaluate(&event, &context).await;

        assert_eq!(result.rule_name, "large_transaction");
        assert!(result.triggered);
        assert!(result.message.is_some());
    }
}
